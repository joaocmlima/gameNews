
import { InjectionToken, Injectable, Inject, Optional, NgZone, ɵɵdefineInjectable, ɵɵinject, NgModule } from '@angular/core';
import { of, from } from 'rxjs';
import { observeOn, switchMap, map, shareReplay } from 'rxjs/operators';
import { ɵAngularFireSchedulers, ɵfirebaseAppFactory, ɵfetchInstance, ɵlazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵapplyMixins } from '@angular/fire';

/**
 * @fileoverview added by tsickle
 * Generated from: base.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
const proxyPolyfillCompat = {
    useEmulator: null,
    useFunctionsEmulator: null,
    httpsCallable: null,
};

/**
 * @fileoverview added by tsickle
 * Generated from: functions.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ORIGIN = new InjectionToken('angularfire2.functions.origin');
/** @type {?} */
const REGION = new InjectionToken('angularfire2.functions.region');
/** @type {?} */
const NEW_ORIGIN_BEHAVIOR = new InjectionToken('angularfire2.functions.new-origin-behavior');
/** @type {?} */
const USE_EMULATOR = new InjectionToken('angularfire2.functions.use-emulator');
// WARNING: interface has both a type and a value, skipping emit
class AngularFireFunctions {
    /**
     * @param {?} options
     * @param {?} nameOrConfig
     * @param {?} zone
     * @param {?} region
     * @param {?} origin
     * @param {?} newOriginBehavior
     * @param {?} _useEmulator
     */
    constructor(options, nameOrConfig, zone, region, origin, newOriginBehavior, _useEmulator) {
        /** @type {?} */
        const schedulers = new ɵAngularFireSchedulers(zone);
        /** @type {?} */
        const useEmulator = _useEmulator;
        /** @type {?} */
        const functions = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap((/**
         * @return {?}
         */
        () => import('firebase/functions'))), map((/**
         * @return {?}
         */
        () => ɵfirebaseAppFactory(options, zone, nameOrConfig))), map((/**
         * @param {?} app
         * @return {?}
         */
        app => ɵfetchInstance(`${app.name}.functions.${region || origin}`, 'AngularFireFunctions', app, (/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            let functions;
            if (newOriginBehavior) {
                if (region && origin) {
                    throw new Error('REGION and ORIGIN can\'t be used at the same time.');
                }
                functions = app.functions(region || origin || undefined);
            }
            else {
                functions = app.functions(region || undefined);
            }
            if (!newOriginBehavior && !useEmulator && origin) {
                functions.useFunctionsEmulator(origin);
            }
            if (useEmulator) {
                functions.useEmulator(...useEmulator);
            }
            return functions;
        }), [region, origin, useEmulator]))), shareReplay({ bufferSize: 1, refCount: false }));
        this.httpsCallable = (/**
         * @template T, R
         * @param {?} name
         * @param {?=} options
         * @return {?}
         */
        (name, options) => (/**
         * @param {?} data
         * @return {?}
         */
        (data) => from(functions).pipe(observeOn(schedulers.insideAngular), switchMap((/**
         * @param {?} functions
         * @return {?}
         */
        functions => functions.httpsCallable(name, options)(data))), map((/**
         * @param {?} r
         * @return {?}
         */
        r => (/** @type {?} */ (r.data)))))));
        return ɵlazySDKProxy(this, functions, zone);
    }
}
AngularFireFunctions.ɵfac = function AngularFireFunctions_Factory(t) { return new (t || AngularFireFunctions)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(REGION, 8), ɵngcc0.ɵɵinject(ORIGIN, 8), ɵngcc0.ɵɵinject(NEW_ORIGIN_BEHAVIOR, 8), ɵngcc0.ɵɵinject(USE_EMULATOR, 8)); };
/** @nocollapse */
AngularFireFunctions.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [FIREBASE_OPTIONS,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [FIREBASE_APP_NAME,] }] },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [REGION,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ORIGIN,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NEW_ORIGIN_BEHAVIOR,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [USE_EMULATOR,] }] }
];
/** @nocollapse */ AngularFireFunctions.ɵprov = ɵɵdefineInjectable({ factory: function AngularFireFunctions_Factory() { return new AngularFireFunctions(ɵɵinject(FIREBASE_OPTIONS), ɵɵinject(FIREBASE_APP_NAME, 8), ɵɵinject(NgZone), ɵɵinject(REGION, 8), ɵɵinject(ORIGIN, 8), ɵɵinject(NEW_ORIGIN_BEHAVIOR, 8), ɵɵinject(USE_EMULATOR, 8)); }, token: AngularFireFunctions, providedIn: "any" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AngularFireFunctions, [{
        type: Injectable,
        args: [{
                providedIn: 'any'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [FIREBASE_OPTIONS]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [FIREBASE_APP_NAME]
            }] }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [REGION]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ORIGIN]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NEW_ORIGIN_BEHAVIOR]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [USE_EMULATOR]
            }] }]; }, null); })();
if (false) {
    /** @type {?} */
    AngularFireFunctions.prototype.httpsCallable;
}
ɵapplyMixins(AngularFireFunctions, [proxyPolyfillCompat]);

/**
 * @fileoverview added by tsickle
 * Generated from: functions.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AngularFireFunctionsModule {
}
AngularFireFunctionsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AngularFireFunctionsModule });
AngularFireFunctionsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AngularFireFunctionsModule_Factory(t) { return new (t || AngularFireFunctionsModule)(); }, providers: [AngularFireFunctions] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AngularFireFunctionsModule, [{
        type: NgModule,
        args: [{
                providers: [AngularFireFunctions]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: angular-fire-functions.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AngularFireFunctions, AngularFireFunctionsModule, NEW_ORIGIN_BEHAVIOR, ORIGIN, REGION, USE_EMULATOR };

//# sourceMappingURL=angular-fire-functions.js.map