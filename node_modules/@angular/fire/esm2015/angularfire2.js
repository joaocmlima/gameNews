/**
 * @fileoverview added by tsickle
 * Generated from: angularfire2.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { asyncScheduler, queueScheduler } from 'rxjs';
import { observeOn, subscribeOn, tap } from 'rxjs/operators';
/**
 * @return {?}
 */
function noop() {
}
/**
 * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.
 */
// tslint:disable-next-line:class-name
export class ɵZoneScheduler {
    /**
     * @param {?} zone
     * @param {?=} delegate
     */
    constructor(zone, delegate = queueScheduler) {
        this.zone = zone;
        this.delegate = delegate;
    }
    /**
     * @return {?}
     */
    now() {
        return this.delegate.now();
    }
    /**
     * @param {?} work
     * @param {?=} delay
     * @param {?=} state
     * @return {?}
     */
    schedule(work, delay, state) {
        /** @type {?} */
        const targetZone = this.zone;
        // Wrap the specified work function to make sure that if nested scheduling takes place the
        // work is executed in the correct zone
        /** @type {?} */
        const workInZone = (/**
         * @this {?}
         * @param {?} state
         * @return {?}
         */
        function (state) {
            targetZone.runGuarded((/**
             * @return {?}
             */
            () => {
                work.apply(this, [state]);
            }));
        });
        // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done
        // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that
        // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.
        return this.delegate.schedule(workInZone, delay, state);
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    ɵZoneScheduler.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    ɵZoneScheduler.prototype.delegate;
}
// tslint:disable-next-line:class-name
/**
 * @template T
 */
export class ɵBlockUntilFirstOperator {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        this.task = null;
    }
    /**
     * @param {?} subscriber
     * @param {?} source
     * @return {?}
     */
    call(subscriber, source) {
        /** @type {?} */
        const unscheduleTask = this.unscheduleTask.bind(this);
        this.task = this.zone.run((/**
         * @return {?}
         */
        () => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop)));
        return source.pipe(tap({ next: unscheduleTask, complete: unscheduleTask, error: unscheduleTask })).subscribe(subscriber).add(unscheduleTask);
    }
    /**
     * @private
     * @return {?}
     */
    unscheduleTask() {
        // maybe this is a race condition, invoke in a timeout
        // hold for 10ms while I try to figure out what is going on
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.task != null && this.task.state === 'scheduled') {
                this.task.invoke();
                this.task = null;
            }
        }), 10);
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    ɵBlockUntilFirstOperator.prototype.task;
    /**
     * @type {?}
     * @private
     */
    ɵBlockUntilFirstOperator.prototype.zone;
}
// tslint:disable-next-line:class-name
export class ɵAngularFireSchedulers {
    /**
     * @param {?} ngZone
     */
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.outsideAngular = ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => new ɵZoneScheduler(Zone.current)));
        this.insideAngular = ngZone.run((/**
         * @return {?}
         */
        () => new ɵZoneScheduler(Zone.current, asyncScheduler)));
    }
}
if (false) {
    /** @type {?} */
    ɵAngularFireSchedulers.prototype.outsideAngular;
    /** @type {?} */
    ɵAngularFireSchedulers.prototype.insideAngular;
    /** @type {?} */
    ɵAngularFireSchedulers.prototype.ngZone;
}
/**
 * Operator to block the zone until the first value has been emitted or the observable
 * has completed/errored. This is used to make sure that universal waits until the first
 * value from firebase but doesn't block the zone forever since the firebase subscription
 * is still alive.
 * @param {?} schedulers
 * @return {?}
 */
export function ɵkeepUnstableUntilFirstFactory(schedulers) {
    return (/**
     * @template T
     * @param {?} obs$
     * @return {?}
     */
    function keepUnstableUntilFirst(obs$) {
        obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));
        return obs$.pipe(
        // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)
        subscribeOn(schedulers.outsideAngular), 
        // Run operators inside the angular zone (e.g. side effects via tap())
        observeOn(schedulers.insideAngular)
        // INVESTIGATE https://github.com/angular/angularfire/pull/2315
        // share()
        );
    });
}
// DEBUG quick debugger function for inline logging that typescript doesn't complain about
//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a
//       verbose mode for AngularFire in a future release that uses something like this in multiple places
//       usage: () => log('something') || returnValue
// const log = (...args: any[]): false => { console.log(...args); return false }
// The problem here are things like ngOnDestroy are missing, then triggering the service
// rather than dig too far; I'm capturing these as I go.
/** @type {?} */
const noopFunctions = ['ngOnDestroy'];
// INVESTIGATE should we make the Proxy revokable and do some cleanup?
//             right now it's fairly simple but I'm sure this will grow in complexity
/** @type {?} */
export const ɵlazySDKProxy = (/**
 * @param {?} klass
 * @param {?} observable
 * @param {?} zone
 * @param {?=} options
 * @return {?}
 */
(klass, observable, zone, options = {}) => {
    return new Proxy(klass, {
        get: (/**
         * @param {?} _
         * @param {?} name
         * @return {?}
         */
        (_, name) => zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            var _a;
            if (klass[name]) {
                if ((_a = options === null || options === void 0 ? void 0 : options.spy) === null || _a === void 0 ? void 0 : _a.get) {
                    options.spy.get(name, klass[name]);
                }
                return klass[name];
            }
            if (noopFunctions.indexOf(name) > -1) {
                return (/**
                 * @return {?}
                 */
                () => {
                });
            }
            /** @type {?} */
            const promise = observable.toPromise().then((/**
             * @param {?} mod
             * @return {?}
             */
            mod => {
                /** @type {?} */
                const ret = mod && mod[name];
                // TODO move to proper type guards
                if (typeof ret === 'function') {
                    return ret.bind(mod);
                }
                else if (ret && ret.then) {
                    return ret.then((/**
                     * @param {?} res
                     * @return {?}
                     */
                    (res) => zone.run((/**
                     * @return {?}
                     */
                    () => res))));
                }
                else {
                    return zone.run((/**
                     * @return {?}
                     */
                    () => ret));
                }
            }));
            // recurse the proxy
            return new Proxy((/**
             * @return {?}
             */
            () => { }), {
                get: (/**
                 * @param {?} _
                 * @param {?} name
                 * @return {?}
                 */
                (_, name) => promise[name]),
                // TODO handle callbacks as transparently as I can
                apply: (/**
                 * @param {?} self
                 * @param {?} _
                 * @param {?} args
                 * @return {?}
                 */
                (self, _, args) => promise.then((/**
                 * @param {?} it
                 * @return {?}
                 */
                it => {
                    var _a;
                    /** @type {?} */
                    const res = it && it(...args);
                    if ((_a = options === null || options === void 0 ? void 0 : options.spy) === null || _a === void 0 ? void 0 : _a.apply) {
                        options.spy.apply(name, args, res);
                    }
                    return res;
                })))
            });
        })))
    });
});
/** @type {?} */
export const ɵapplyMixins = (/**
 * @param {?} derivedCtor
 * @param {?} constructors
 * @return {?}
 */
(derivedCtor, constructors) => {
    constructors.forEach((/**
     * @param {?} baseCtor
     * @return {?}
     */
    (baseCtor) => {
        Object.getOwnPropertyNames(baseCtor.prototype || baseCtor).forEach((/**
         * @param {?} name
         * @return {?}
         */
        (name) => {
            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype || baseCtor, name));
        }));
    }));
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhcmZpcmUyLmpzIiwic291cmNlUm9vdCI6Ii93b3Jrc3BhY2Uvc3JjL2NvcmUvIiwic291cmNlcyI6WyJhbmd1bGFyZmlyZTIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSxPQUFPLEVBQ0wsY0FBYyxFQUdkLGNBQWMsRUFNZixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7O0FBRTdELFNBQVMsSUFBSTtBQUNiLENBQUM7Ozs7O0FBTUQsTUFBTSxPQUFPLGNBQWM7Ozs7O0lBQ3pCLFlBQW9CLElBQVMsRUFBVSxXQUFnQixjQUFjO1FBQWpELFNBQUksR0FBSixJQUFJLENBQUs7UUFBVSxhQUFRLEdBQVIsUUFBUSxDQUFzQjtJQUNyRSxDQUFDOzs7O0lBRUQsR0FBRztRQUNELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUM3QixDQUFDOzs7Ozs7O0lBRUQsUUFBUSxDQUFDLElBQXVELEVBQUUsS0FBYyxFQUFFLEtBQVc7O2NBQ3JGLFVBQVUsR0FBRyxJQUFJLENBQUMsSUFBSTs7OztjQUd0QixVQUFVOzs7OztRQUFHLFVBQXFDLEtBQVU7WUFDaEUsVUFBVSxDQUFDLFVBQVU7OztZQUFDLEdBQUcsRUFBRTtnQkFDekIsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzVCLENBQUMsRUFBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFBO1FBRUQsc0dBQXNHO1FBQ3RHLGlHQUFpRztRQUNqRywrR0FBK0c7UUFDL0csT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzFELENBQUM7Q0FDRjs7Ozs7O0lBdEJhLDhCQUFpQjs7Ozs7SUFBRSxrQ0FBc0M7Ozs7OztBQXlCdkUsTUFBTSxPQUFP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eyBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIGFzeW5jU2NoZWR1bGVyLFxuICBPYnNlcnZhYmxlLFxuICBPcGVyYXRvcixcbiAgcXVldWVTY2hlZHVsZXIsXG4gIFNjaGVkdWxlckFjdGlvbixcbiAgU2NoZWR1bGVyTGlrZSxcbiAgU3Vic2NyaWJlcixcbiAgU3Vic2NyaXB0aW9uLFxuICBUZWFyZG93bkxvZ2ljXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgb2JzZXJ2ZU9uLCBzdWJzY3JpYmVPbiwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5mdW5jdGlvbiBub29wKCkge1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyB0YXNrcyBzbyB0aGF0IHRoZXkgYXJlIGludm9rZWQgaW5zaWRlIHRoZSBab25lIHRoYXQgaXMgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmNsYXNzLW5hbWVcbmV4cG9ydCBjbGFzcyDJtVpvbmVTY2hlZHVsZXIgaW1wbGVtZW50cyBTY2hlZHVsZXJMaWtlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB6b25lOiBhbnksIHByaXZhdGUgZGVsZWdhdGU6IGFueSA9IHF1ZXVlU2NoZWR1bGVyKSB7XG4gIH1cblxuICBub3coKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubm93KCk7XG4gIH1cblxuICBzY2hlZHVsZSh3b3JrOiAodGhpczogU2NoZWR1bGVyQWN0aW9uPGFueT4sIHN0YXRlPzogYW55KSA9PiB2b2lkLCBkZWxheT86IG51bWJlciwgc3RhdGU/OiBhbnkpOiBTdWJzY3JpcHRpb24ge1xuICAgIGNvbnN0IHRhcmdldFpvbmUgPSB0aGlzLnpvbmU7XG4gICAgLy8gV3JhcCB0aGUgc3BlY2lmaWVkIHdvcmsgZnVuY3Rpb24gdG8gbWFrZSBzdXJlIHRoYXQgaWYgbmVzdGVkIHNjaGVkdWxpbmcgdGFrZXMgcGxhY2UgdGhlXG4gICAgLy8gd29yayBpcyBleGVjdXRlZCBpbiB0aGUgY29ycmVjdCB6b25lXG4gICAgY29uc3Qgd29ya0luWm9uZSA9IGZ1bmN0aW9uKHRoaXM6IFNjaGVkdWxlckFjdGlvbjxhbnk+LCBzdGF0ZTogYW55KSB7XG4gICAgICB0YXJnZXRab25lLnJ1bkd1YXJkZWQoKCkgPT4ge1xuICAgICAgICB3b3JrLmFwcGx5KHRoaXMsIFtzdGF0ZV0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFNjaGVkdWxpbmcgaXRzZWxmIG5lZWRzIHRvIGJlIHJ1biBpbiB6b25lIHRvIGVuc3VyZSBzZXRJbnRlcnZhbCBjYWxscyBmb3IgYXN5bmMgc2NoZWR1bGluZyBhcmUgZG9uZVxuICAgIC8vIGluc2lkZSB0aGUgY29ycmVjdCB6b25lLiBUaGlzIHNjaGVkdWxlciBuZWVkcyB0byBzY2hlZHVsZSBhc3luY2hyb25vdXNseSBhbHdheXMgdG8gZW5zdXJlIHRoYXRcbiAgICAvLyBmaXJlYmFzZSBlbWlzc2lvbnMgYXJlIG5ldmVyIHN5bmNocm9ub3VzLiBTcGVjaWZ5aW5nIGEgZGVsYXkgY2F1c2VzIGlzc3VlcyB3aXRoIHRoZSBxdWV1ZVNjaGVkdWxlciBkZWxlZ2F0ZS5cbiAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5zY2hlZHVsZSh3b3JrSW5ab25lLCBkZWxheSwgc3RhdGUpO1xuICB9XG59XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjbGFzcy1uYW1lXG5leHBvcnQgY2xhc3MgybVCbG9ja1VudGlsRmlyc3RPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFQ+IHtcbiAgcHJpdmF0ZSB0YXNrOiBNYWNyb1Rhc2sgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHpvbmU6IGFueSkge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LCBzb3VyY2U6IE9ic2VydmFibGU8VD4pOiBUZWFyZG93bkxvZ2ljIHtcbiAgICBjb25zdCB1bnNjaGVkdWxlVGFzayA9IHRoaXMudW5zY2hlZHVsZVRhc2suYmluZCh0aGlzKTtcbiAgICB0aGlzLnRhc2sgPSB0aGlzLnpvbmUucnVuKCgpID0+IFpvbmUuY3VycmVudC5zY2hlZHVsZU1hY3JvVGFzaygnZmlyZWJhc2Vab25lQmxvY2snLCBub29wLCB7fSwgbm9vcCwgbm9vcCkpO1xuXG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKFxuICAgICAgdGFwKHsgbmV4dDogdW5zY2hlZHVsZVRhc2ssIGNvbXBsZXRlOiB1bnNjaGVkdWxlVGFzaywgZXJyb3I6IHVuc2NoZWR1bGVUYXNrIH0pXG4gICAgKS5zdWJzY3JpYmUoc3Vic2NyaWJlcikuYWRkKHVuc2NoZWR1bGVUYXNrKTtcbiAgfVxuXG4gIHByaXZhdGUgdW5zY2hlZHVsZVRhc2soKSB7XG4gICAgLy8gbWF5YmUgdGhpcyBpcyBhIHJhY2UgY29uZGl0aW9uLCBpbnZva2UgaW4gYSB0aW1lb3V0XG4gICAgLy8gaG9sZCBmb3IgMTBtcyB3aGlsZSBJIHRyeSB0byBmaWd1cmUgb3V0IHdoYXQgaXMgZ29pbmcgb25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnRhc2sgIT0gbnVsbCAmJiB0aGlzLnRhc2suc3RhdGUgPT09ICdzY2hlZHVsZWQnKSB7XG4gICAgICAgIHRoaXMudGFzay5pbnZva2UoKTtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LCAxMCk7XG4gIH1cbn1cblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmNsYXNzLW5hbWVcbmV4cG9ydCBjbGFzcyDJtUFuZ3VsYXJGaXJlU2NoZWR1bGVycyB7XG4gIHB1YmxpYyByZWFkb25seSBvdXRzaWRlQW5ndWxhcjogybVab25lU2NoZWR1bGVyO1xuICBwdWJsaWMgcmVhZG9ubHkgaW5zaWRlQW5ndWxhcjogybVab25lU2NoZWR1bGVyO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBuZ1pvbmU6IE5nWm9uZSkge1xuICAgIHRoaXMub3V0c2lkZUFuZ3VsYXIgPSBuZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gbmV3IMm1Wm9uZVNjaGVkdWxlcihab25lLmN1cnJlbnQpKTtcbiAgICB0aGlzLmluc2lkZUFuZ3VsYXIgPSBuZ1pvbmUucnVuKCgpID0+IG5ldyDJtVpvbmVTY2hlZHVsZXIoWm9uZS5jdXJyZW50LCBhc3luY1NjaGVkdWxlcikpO1xuICB9XG59XG5cbi8qKlxuICogT3BlcmF0b3IgdG8gYmxvY2sgdGhlIHpvbmUgdW50aWwgdGhlIGZpcnN0IHZhbHVlIGhhcyBiZWVuIGVtaXR0ZWQgb3IgdGhlIG9ic2VydmFibGVcbiAqIGhhcyBjb21wbGV0ZWQvZXJyb3JlZC4gVGhpcyBpcyB1c2VkIHRvIG1ha2Ugc3VyZSB0aGF0IHVuaXZlcnNhbCB3YWl0cyB1bnRpbCB0aGUgZmlyc3RcbiAqIHZhbHVlIGZyb20gZmlyZWJhc2UgYnV0IGRvZXNuJ3QgYmxvY2sgdGhlIHpvbmUgZm9yZXZlciBzaW5jZSB0aGUgZmlyZWJhc2Ugc3Vic2NyaXB0aW9uXG4gKiBpcyBzdGlsbCBhbGl2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIMm1a2VlcFVuc3RhYmxlVW50aWxGaXJzdEZhY3Rvcnkoc2NoZWR1bGVyczogybVBbmd1bGFyRmlyZVNjaGVkdWxlcnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtlZXBVbnN0YWJsZVVudGlsRmlyc3Q8VD4ob2JzJDogT2JzZXJ2YWJsZTxUPik6IE9ic2VydmFibGU8VD4ge1xuICAgIG9icyQgPSBvYnMkLmxpZnQoXG4gICAgICBuZXcgybVCbG9ja1VudGlsRmlyc3RPcGVyYXRvcihzY2hlZHVsZXJzLm5nWm9uZSlcbiAgICApO1xuXG4gICAgcmV0dXJuIG9icyQucGlwZShcbiAgICAgIC8vIFJ1biB0aGUgc3Vic2NyaWJlIGJvZHkgb3V0c2lkZSBvZiBBbmd1bGFyIChlLmcuIGNhbGxpbmcgRmlyZWJhc2UgU0RLIHRvIGFkZCBhIGxpc3RlbmVyIHRvIGEgY2hhbmdlIGV2ZW50KVxuICAgICAgc3Vic2NyaWJlT24oc2NoZWR1bGVycy5vdXRzaWRlQW5ndWxhciksXG4gICAgICAvLyBSdW4gb3BlcmF0b3JzIGluc2lkZSB0aGUgYW5ndWxhciB6b25lIChlLmcuIHNpZGUgZWZmZWN0cyB2aWEgdGFwKCkpXG4gICAgICBvYnNlcnZlT24oc2NoZWR1bGVycy5pbnNpZGVBbmd1bGFyKVxuICAgICAgLy8gSU5WRVNUSUdBVEUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhcmZpcmUvcHVsbC8yMzE1XG4gICAgICAvLyBzaGFyZSgpXG4gICAgKTtcbiAgfTtcbn1cblxuLy8gdHNsaW50OmRpc2FibGU6YmFuLXR5cGVzXG50eXBlIEZ1bmN0aW9uUHJvcGVydHlOYW1lczxUPiA9IHsgW0sgaW4ga2V5b2YgVF06IFRbS10gZXh0ZW5kcyBGdW5jdGlvbiA/IEsgOiBuZXZlciB9W2tleW9mIFRdO1xudHlwZSBQcm9taXNlUmV0dXJuaW5nRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+ID0ge1xuICBbSyBpbiBGdW5jdGlvblByb3BlcnR5TmFtZXM8VD5dOiBSZXR1cm5UeXBlPFRbS10+IGV4dGVuZHMgUHJvbWlzZTxhbnk+ID8gSyA6IG5ldmVyXG59W0Z1bmN0aW9uUHJvcGVydHlOYW1lczxUPl07XG50eXBlIE5vblByb21pc2VSZXR1cm5pbmdGdW5jdGlvblByb3BlcnR5TmFtZXM8VD4gPSB7XG4gIFtLIGluIEZ1bmN0aW9uUHJvcGVydHlOYW1lczxUPl06IFJldHVyblR5cGU8VFtLXT4gZXh0ZW5kcyBQcm9taXNlPGFueT4gPyBuZXZlciA6IEtcbn1bRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+XTtcbnR5cGUgTm9uRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+ID0geyBbSyBpbiBrZXlvZiBUXTogVFtLXSBleHRlbmRzIEZ1bmN0aW9uID8gbmV2ZXIgOiBLIH1ba2V5b2YgVF07XG4vLyB0c2xpbnQ6ZW5hYmxlOmJhbi10eXBlc1xuXG5leHBvcnQgdHlwZSDJtVByb21pc2VQcm94eTxUPiA9IHsgW0sgaW4gTm9uRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+XTogUHJvbWlzZTxUW0tdPiB9ICZcbiAgeyBbSyBpbiBOb25Qcm9taXNlUmV0dXJuaW5nRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+XTogKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VFtLXT4pID0+IFByb21pc2U8UmV0dXJuVHlwZTxUW0tdPj4gfSAmXG4gIHsgW0sgaW4gUHJvbWlzZVJldHVybmluZ0Z1bmN0aW9uUHJvcGVydHlOYW1lczxUPl06ICguLi5hcmdzOiBQYXJhbWV0ZXJzPFRbS10+KSA9PiBSZXR1cm5UeXBlPFRbS10+IH07XG5cblxuLy8gREVCVUcgcXVpY2sgZGVidWdnZXIgZnVuY3Rpb24gZm9yIGlubGluZSBsb2dnaW5nIHRoYXQgdHlwZXNjcmlwdCBkb2Vzbid0IGNvbXBsYWluIGFib3V0XG4vLyAgICAgICB3cm90ZSBpdCBmb3IgZGVidWdnaW5nIHRoZSDJtWxhenlTREtQcm94eSwgY29tbWVudGluZyBvdXQgZm9yIG5vdzsgc2hvdWxkIGNvbnNpZGVyIGV4cG9zaW5nIGFcbi8vICAgICAgIHZlcmJvc2UgbW9kZSBmb3IgQW5ndWxhckZpcmUgaW4gYSBmdXR1cmUgcmVsZWFzZSB0aGF0IHVzZXMgc29tZXRoaW5nIGxpa2UgdGhpcyBpbiBtdWx0aXBsZSBwbGFjZXNcbi8vICAgICAgIHVzYWdlOiAoKSA9PiBsb2coJ3NvbWV0aGluZycpIHx8IHJldHVyblZhbHVlXG4vLyBjb25zdCBsb2cgPSAoLi4uYXJnczogYW55W10pOiBmYWxzZSA9PiB7IGNvbnNvbGUubG9nKC4uLmFyZ3MpOyByZXR1cm4gZmFsc2UgfVxuXG4vLyBUaGUgcHJvYmxlbSBoZXJlIGFyZSB0aGluZ3MgbGlrZSBuZ09uRGVzdHJveSBhcmUgbWlzc2luZywgdGhlbiB0cmlnZ2VyaW5nIHRoZSBzZXJ2aWNlXG4vLyByYXRoZXIgdGhhbiBkaWcgdG9vIGZhcjsgSSdtIGNhcHR1cmluZyB0aGVzZSBhcyBJIGdvLlxuY29uc3Qgbm9vcEZ1bmN0aW9ucyA9IFsnbmdPbkRlc3Ryb3knXTtcblxuLy8gSU5WRVNUSUdBVEUgc2hvdWxkIHdlIG1ha2UgdGhlIFByb3h5IHJldm9rYWJsZSBhbmQgZG8gc29tZSBjbGVhbnVwP1xuLy8gICAgICAgICAgICAgcmlnaHQgbm93IGl0J3MgZmFpcmx5IHNpbXBsZSBidXQgSSdtIHN1cmUgdGhpcyB3aWxsIGdyb3cgaW4gY29tcGxleGl0eVxuZXhwb3J0IGNvbnN0IMm1bGF6eVNES1Byb3h5ID0gKGtsYXNzOiBhbnksIG9ic2VydmFibGU6IE9ic2VydmFibGU8YW55Piwgem9uZTogTmdab25lLCBvcHRpb25zOiB7XG4gIHNweT86IHtcbiAgICBnZXQ/OiAoKG5hbWU6IHN0cmluZywgaXQ6IGFueSkgPT4gdm9pZCksXG4gICAgYXBwbHk/OiAoKG5hbWU6IHN0cmluZywgYXJnczogYW55W10sIGl0OiBhbnkpID0+IHZvaWQpXG4gIH1cbn0gPSB7fSkgPT4ge1xuICByZXR1cm4gbmV3IFByb3h5KGtsYXNzLCB7XG4gICAgZ2V0OiAoXywgbmFtZTogc3RyaW5nKSA9PiB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgIGlmIChrbGFzc1tuYW1lXSkge1xuICAgICAgICBpZiAob3B0aW9ucz8uc3B5Py5nZXQpIHtcbiAgICAgICAgICBvcHRpb25zLnNweS5nZXQobmFtZSwga2xhc3NbbmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrbGFzc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIGlmIChub29wRnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvbWlzZSA9IG9ic2VydmFibGUudG9Qcm9taXNlKCkudGhlbihtb2QgPT4ge1xuICAgICAgICBjb25zdCByZXQgPSBtb2QgJiYgbW9kW25hbWVdO1xuICAgICAgICAvLyBUT0RPIG1vdmUgdG8gcHJvcGVyIHR5cGUgZ3VhcmRzXG4gICAgICAgIGlmICh0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHJldC5iaW5kKG1vZCk7XG4gICAgICAgIH0gZWxzZSBpZiAocmV0ICYmIHJldC50aGVuKSB7XG4gICAgICAgICAgcmV0dXJuIHJldC50aGVuKChyZXM6IGFueSkgPT4gem9uZS5ydW4oKCkgPT4gcmVzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHpvbmUucnVuKCgpID0+IHJldCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gcmVjdXJzZSB0aGUgcHJveHlcbiAgICAgIHJldHVybiBuZXcgUHJveHkoKCkgPT4ge30sIHtcbiAgICAgICAgICBnZXQ6IChfLCBuYW1lKSA9PiBwcm9taXNlW25hbWVdLFxuICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIGNhbGxiYWNrcyBhcyB0cmFuc3BhcmVudGx5IGFzIEkgY2FuXG4gICAgICAgICAgYXBwbHk6IChzZWxmLCBfLCBhcmdzKSA9PiBwcm9taXNlLnRoZW4oaXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gaXQgJiYgaXQoLi4uYXJncyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucz8uc3B5Py5hcHBseSkge1xuICAgICAgICAgICAgICBvcHRpb25zLnNweS5hcHBseShuYW1lLCBhcmdzLCByZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pXG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IMm1YXBwbHlNaXhpbnMgPSAoZGVyaXZlZEN0b3I6IGFueSwgY29uc3RydWN0b3JzOiBhbnlbXSkgPT4ge1xuICBjb25zdHJ1Y3RvcnMuZm9yRWFjaCgoYmFzZUN0b3IpID0+IHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiYXNlQ3Rvci5wcm90b3R5cGUgfHwgYmFzZUN0b3IpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgZGVyaXZlZEN0b3IucHJvdG90eXBlLFxuICAgICAgICBuYW1lLFxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2VDdG9yLnByb3RvdHlwZSB8fCBiYXNlQ3RvciwgbmFtZSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufTtcbiJdfQ==