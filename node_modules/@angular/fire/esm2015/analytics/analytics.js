/**
 * @fileoverview added by tsickle
 * Generated from: analytics.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { __awaiter } from "tslib";
import { Inject, Injectable, InjectionToken, NgZone, Optional, PLATFORM_ID } from '@angular/core';
import { EMPTY, of } from 'rxjs';
import { isPlatformBrowser } from '@angular/common';
import { map, shareReplay, switchMap, observeOn } from 'rxjs/operators';
import { ɵAngularFireSchedulers, ɵlazySDKProxy, ɵapplyMixins, FirebaseApp } from '@angular/fire';
import firebase from 'firebase/app';
import { proxyPolyfillCompat } from './base';
import { ɵfetchInstance } from '@angular/fire';
import * as i0 from "@angular/core";
import * as i1 from "@angular/fire";
/**
 * @record
 */
export function Config() { }
/** @type {?} */
export const COLLECTION_ENABLED = new InjectionToken('angularfire2.analytics.analyticsCollectionEnabled');
/** @type {?} */
export const APP_VERSION = new InjectionToken('angularfire2.analytics.appVersion');
/** @type {?} */
export const APP_NAME = new InjectionToken('angularfire2.analytics.appName');
/** @type {?} */
export const DEBUG_MODE = new InjectionToken('angularfire2.analytics.debugMode');
/** @type {?} */
export const CONFIG = new InjectionToken('angularfire2.analytics.config');
/** @type {?} */
const APP_NAME_KEY = 'app_name';
/** @type {?} */
const APP_VERSION_KEY = 'app_version';
/** @type {?} */
const DEBUG_MODE_KEY = 'debug_mode';
/** @type {?} */
const GTAG_CONFIG_COMMAND = 'config';
/** @type {?} */
const GTAG_FUNCTION_NAME = 'gtag';
// TODO rename these
/** @type {?} */
const DATA_LAYER_NAME = 'dataLayer';
/** @type {?} */
const SEND_TO_KEY = 'send_to';
// WARNING: interface has both a type and a value, skipping emit
export class AngularFireAnalytics {
    /**
     * @param {?} app
     * @param {?} analyticsCollectionEnabled
     * @param {?} providedAppVersion
     * @param {?} providedAppName
     * @param {?} debugModeEnabled
     * @param {?} providedConfig
     * @param {?} platformId
     * @param {?} zone
     */
    constructor(app, analyticsCollectionEnabled, providedAppVersion, providedAppName, debugModeEnabled, providedConfig, 
    // tslint:disable-next-line:ban-types
    platformId, zone) {
        this.analyticsInitialized = new Promise((/**
         * @return {?}
         */
        () => { }));
        if (isPlatformBrowser(platformId)) {
            window[DATA_LAYER_NAME] = window[DATA_LAYER_NAME] || [];
            // It turns out we can't rely on the measurementId in the Firebase config JSON
            // this identifier is not stable. firebase/analytics does a call to get a fresh value
            // falling back on the one in the config. Rather than do that ourselves we should listen
            // on our gtag function for a analytics config command
            // e.g, ['config', measurementId, { origin: 'firebase', firebase_id }]
            /** @type {?} */
            const parseMeasurementId = (/**
             * @param {...?} args
             * @return {?}
             */
            (...args) => {
                if (args[0] === 'config' && args[2].origin === 'firebase') {
                    this.measurementId = args[1];
                    return true;
                }
                else {
                    return false;
                }
            });
            /** @type {?} */
            const patchGtag = (/**
             * @param {?=} fn
             * @return {?}
             */
            (fn) => {
                window[GTAG_FUNCTION_NAME] = (/**
                 * @param {...?} args
                 * @return {?}
                 */
                (...args) => {
                    if (fn) {
                        fn(...args);
                    }
                    // Inject app_name and app_version into events
                    // TODO(jamesdaniels): I'm doing this as documented but it's still not
                    //   showing up in the console. Investigate. Guessing it's just part of the
                    //   whole GA4 transition mess.
                    if (args[0] === 'event' && args[2][SEND_TO_KEY] === this.measurementId) {
                        if (providedAppName) {
                            args[2][APP_NAME_KEY] = providedAppName;
                        }
                        if (providedAppVersion) {
                            args[2][APP_VERSION_KEY] = providedAppVersion;
                        }
                    }
                    if (debugModeEnabled && typeof console !== 'undefined') {
                        // tslint:disable-next-line:no-console
                        console.info(...args);
                    }
                    /**
                     * According to the gtag documentation, this function that defines a custom data layer cannot be
                     * an arrow function because 'arguments' is not an array. It is actually an object that behaves
                     * like an array and contains more information then just indexes. Transforming this into arrow function
                     * caused issue #2505 where analytics no longer sent any data.
                     */
                    // tslint:disable-next-line: only-arrow-functions
                    ((/**
                     * @param {...?} _args
                     * @return {?}
                     */
                    function (..._args) {
                        window[DATA_LAYER_NAME].push(arguments);
                    }))(...args);
                });
            });
            // Unclear if we still need to but I was running into config/events I passed
            // to gtag before ['js' timestamp] weren't getting parsed, so let's make a promise
            // that resolves when firebase/analytics has configured gtag.js that we wait on
            // before sending anything
            /** @type {?} */
            const firebaseAnalyticsAlreadyInitialized = window[DATA_LAYER_NAME].some(parseMeasurementId);
            if (firebaseAnalyticsAlreadyInitialized) {
                this.analyticsInitialized = Promise.resolve();
                patchGtag();
            }
            else {
                this.analyticsInitialized = new Promise((/**
                 * @param {?} resolve
                 * @return {?}
                 */
                resolve => {
                    patchGtag((/**
                     * @param {...?} args
                     * @return {?}
                     */
                    (...args) => {
                        if (parseMeasurementId(...args)) {
                            resolve();
                        }
                    }));
                }));
            }
            if (providedConfig) {
                this.updateConfig(providedConfig);
            }
            if (debugModeEnabled) {
                this.updateConfig({ [DEBUG_MODE_KEY]: 1 });
            }
        }
        else {
            this.analyticsInitialized = Promise.resolve();
        }
        /** @type {?} */
        const analytics = of(undefined).pipe(observeOn(new ɵAngularFireSchedulers(zone).outsideAngular), switchMap((/**
         * @return {?}
         */
        () => import('firebase/analytics'))), switchMap((/**
         * @return {?}
         */
        () => firebase.analytics.isSupported().then((/**
         * @param {?} it
         * @return {?}
         */
        it => it), (/**
         * @return {?}
         */
        () => false)))), 
        // TODO server-side investigate use of the Universal Analytics API
        switchMap((/**
         * @param {?} supported
         * @return {?}
         */
        supported => supported ? of(undefined) : EMPTY)), map((/**
         * @return {?}
         */
        () => {
            return ɵfetchInstance(`analytics`, 'AngularFireAnalytics', app, (/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const analytics = app.analytics();
                if (analyticsCollectionEnabled === false) {
                    analytics.setAnalyticsCollectionEnabled(false);
                }
                return analytics;
            }), [app, analyticsCollectionEnabled, providedConfig, debugModeEnabled]);
        })), shareReplay({ bufferSize: 1, refCount: false }));
        return ɵlazySDKProxy(this, analytics, zone);
    }
    /**
     * @param {?} config
     * @return {?}
     */
    updateConfig(config) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.analyticsInitialized;
            window[GTAG_FUNCTION_NAME](GTAG_CONFIG_COMMAND, this.measurementId, Object.assign(Object.assign({}, config), { update: true }));
        });
    }
}
AngularFireAnalytics.decorators = [
    { type: Injectable, args: [{
                providedIn: 'any'
            },] }
];
/** @nocollapse */
AngularFireAnalytics.ctorParameters = () => [
    { type: FirebaseApp },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [COLLECTION_ENABLED,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [APP_VERSION,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [APP_NAME,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DEBUG_MODE,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONFIG,] }] },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: NgZone }
];
/** @nocollapse */ AngularFireAnalytics.ɵprov = i0.ɵɵdefineInjectable({ factory: function AngularFireAnalytics_Factory() { return new AngularFireAnalytics(i0.ɵɵinject(i1.FirebaseApp), i0.ɵɵinject(COLLECTION_ENABLED, 8), i0.ɵɵinject(APP_VERSION, 8), i0.ɵɵinject(APP_NAME, 8), i0.ɵɵinject(DEBUG_MODE, 8), i0.ɵɵinject(CONFIG, 8), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i0.NgZone)); }, token: AngularFireAnalytics, providedIn: "any" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    AngularFireAnalytics.prototype.measurementId;
    /**
     * @type {?}
     * @private
     */
    AngularFireAnalytics.prototype.analyticsInitialized;
}
ɵapplyMixins(AngularFireAnalytics, [proxyPolyfillCompat]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5hbHl0aWNzLmpzIiwic291cmNlUm9vdCI6Ii93b3Jrc3BhY2Uvc3JjL2FuYWx5dGljcy8iLCJzb3VyY2VzIjpbImFuYWx5dGljcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEcsT0FBTyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDakMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDcEQsT0FBTyxFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hFLE9BQU8sRUFDTCxzQkFBc0IsRUFDdEIsYUFBYSxFQUViLFlBQVksRUFDWixXQUFXLEVBQ1osTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxRQUFRLE1BQU0sY0FBYyxDQUFDO0FBQ3BDLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUM3QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sZUFBZSxDQUFDOzs7Ozs7QUFFL0MsNEJBRUM7O0FBRUQsTUFBTSxPQUFPLGtCQUFrQixHQUFHLElBQUksY0FBYyxDQUFVLG1EQUFtRCxDQUFDOztBQUNsSCxNQUFNLE9BQU8sV0FBVyxHQUFHLElBQUksY0FBYyxDQUFTLG1DQUFtQyxDQUFDOztBQUMxRixNQUFNLE9BQU8sUUFBUSxHQUFHLElBQUksY0FBYyxDQUFTLGdDQUFnQyxDQUFDOztBQUNwRixNQUFNLE9BQU8sVUFBVSxHQUFHLElBQUksY0FBYyxDQUFVLGtDQUFrQyxDQUFDOztBQUN6RixNQUFNLE9BQU8sTUFBTSxHQUFHLElBQUksY0FBYyxDQUFTLCtCQUErQixDQUFDOztNQUUzRSxZQUFZLEdBQUcsVUFBVTs7TUFDekIsZUFB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QUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBOZ1pvbmUsIE9wdGlvbmFsLCBQTEFURk9STV9JRCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRU1QVFksIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBtYXAsIHNoYXJlUmVwbGF5LCBzd2l0Y2hNYXAsIG9ic2VydmVPbiB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7XG4gIMm1QW5ndWxhckZpcmVTY2hlZHVsZXJzLFxuICDJtWxhenlTREtQcm94eSxcbiAgybVQcm9taXNlUHJveHksXG4gIMm1YXBwbHlNaXhpbnMsXG4gIEZpcmViYXNlQXBwXG59IGZyb20gJ0Bhbmd1bGFyL2ZpcmUnO1xuaW1wb3J0IGZpcmViYXNlIGZyb20gJ2ZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBwcm94eVBvbHlmaWxsQ29tcGF0IH0gZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7IMm1ZmV0Y2hJbnN0YW5jZSB9IGZyb20gJ0Bhbmd1bGFyL2ZpcmUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbmZpZyB7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IGNvbnN0IENPTExFQ1RJT05fRU5BQkxFRCA9IG5ldyBJbmplY3Rpb25Ub2tlbjxib29sZWFuPignYW5ndWxhcmZpcmUyLmFuYWx5dGljcy5hbmFseXRpY3NDb2xsZWN0aW9uRW5hYmxlZCcpO1xuZXhwb3J0IGNvbnN0IEFQUF9WRVJTSU9OID0gbmV3IEluamVjdGlvblRva2VuPHN0cmluZz4oJ2FuZ3VsYXJmaXJlMi5hbmFseXRpY3MuYXBwVmVyc2lvbicpO1xuZXhwb3J0IGNvbnN0IEFQUF9OQU1FID0gbmV3IEluamVjdGlvblRva2VuPHN0cmluZz4oJ2FuZ3VsYXJmaXJlMi5hbmFseXRpY3MuYXBwTmFtZScpO1xuZXhwb3J0IGNvbnN0IERFQlVHX01PREUgPSBuZXcgSW5qZWN0aW9uVG9rZW48Ym9vbGVhbj4oJ2FuZ3VsYXJmaXJlMi5hbmFseXRpY3MuZGVidWdNb2RlJyk7XG5leHBvcnQgY29uc3QgQ09ORklHID0gbmV3IEluamVjdGlvblRva2VuPENvbmZpZz4oJ2FuZ3VsYXJmaXJlMi5hbmFseXRpY3MuY29uZmlnJyk7XG5cbmNvbnN0IEFQUF9OQU1FX0tFWSA9ICdhcHBfbmFtZSc7XG5jb25zdCBBUFBfVkVSU0lPTl9LRVkgPSAnYXBwX3ZlcnNpb24nO1xuY29uc3QgREVCVUdfTU9ERV9LRVkgPSAnZGVidWdfbW9kZSc7XG5jb25zdCBHVEFHX0NPTkZJR19DT01NQU5EID0gJ2NvbmZpZyc7XG5jb25zdCBHVEFHX0ZVTkNUSU9OX05BTUUgPSAnZ3RhZyc7IC8vIFRPRE8gcmVuYW1lIHRoZXNlXG5jb25zdCBEQVRBX0xBWUVSX05BTUUgPSAnZGF0YUxheWVyJztcbmNvbnN0IFNFTkRfVE9fS0VZID0gJ3NlbmRfdG8nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFuZ3VsYXJGaXJlQW5hbHl0aWNzIGV4dGVuZHMgybVQcm9taXNlUHJveHk8ZmlyZWJhc2UuYW5hbHl0aWNzLkFuYWx5dGljcz4ge1xufVxuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdhbnknXG59KVxuZXhwb3J0IGNsYXNzIEFuZ3VsYXJGaXJlQW5hbHl0aWNzIHtcblxuICBwcml2YXRlIG1lYXN1cmVtZW50SWQ6IHN0cmluZztcbiAgcHJpdmF0ZSBhbmFseXRpY3NJbml0aWFsaXplZDogUHJvbWlzZTx2b2lkPiA9IG5ldyBQcm9taXNlKCgpID0+IHt9KTtcblxuICBhc3luYyB1cGRhdGVDb25maWcoY29uZmlnOiBDb25maWcpIHtcbiAgICBhd2FpdCB0aGlzLmFuYWx5dGljc0luaXRpYWxpemVkO1xuICAgIHdpbmRvd1tHVEFHX0ZVTkNUSU9OX05BTUVdKEdUQUdfQ09ORklHX0NPTU1BTkQsIHRoaXMubWVhc3VyZW1lbnRJZCwgeyAuLi5jb25maWcsIHVwZGF0ZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGFwcDogRmlyZWJhc2VBcHAsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChDT0xMRUNUSU9OX0VOQUJMRUQpIGFuYWx5dGljc0NvbGxlY3Rpb25FbmFibGVkOiBib29sZWFuIHwgbnVsbCxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KEFQUF9WRVJTSU9OKSBwcm92aWRlZEFwcFZlcnNpb246IHN0cmluZyB8IG51bGwsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChBUFBfTkFNRSkgcHJvdmlkZWRBcHBOYW1lOiBzdHJpbmcgfCBudWxsLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoREVCVUdfTU9ERSkgZGVidWdNb2RlRW5hYmxlZDogYm9vbGVhbiB8IG51bGwsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChDT05GSUcpIHByb3ZpZGVkQ29uZmlnOiBDb25maWcgfCBudWxsLFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpiYW4tdHlwZXNcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwbGF0Zm9ybUlkOiBPYmplY3QsXG4gICAgem9uZTogTmdab25lXG4gICkge1xuXG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHBsYXRmb3JtSWQpKSB7XG5cbiAgICAgIHdpbmRvd1tEQVRBX0xBWUVSX05BTUVdID0gd2luZG93W0RBVEFfTEFZRVJfTkFNRV0gfHwgW107XG5cbiAgICAgIC8vIEl0IHR1cm5zIG91dCB3ZSBjYW4ndCByZWx5IG9uIHRoZSBtZWFzdXJlbWVudElkIGluIHRoZSBGaXJlYmFzZSBjb25maWcgSlNPTlxuICAgICAgLy8gdGhpcyBpZGVudGlmaWVyIGlzIG5vdCBzdGFibGUuIGZpcmViYXNlL2FuYWx5dGljcyBkb2VzIGEgY2FsbCB0byBnZXQgYSBmcmVzaCB2YWx1ZVxuICAgICAgLy8gZmFsbGluZyBiYWNrIG9uIHRoZSBvbmUgaW4gdGhlIGNvbmZpZy4gUmF0aGVyIHRoYW4gZG8gdGhhdCBvdXJzZWx2ZXMgd2Ugc2hvdWxkIGxpc3RlblxuICAgICAgLy8gb24gb3VyIGd0YWcgZnVuY3Rpb24gZm9yIGEgYW5hbHl0aWNzIGNvbmZpZyBjb21tYW5kXG4gICAgICAvLyBlLmcsIFsnY29uZmlnJywgbWVhc3VyZW1lbnRJZCwgeyBvcmlnaW46ICdmaXJlYmFzZScsIGZpcmViYXNlX2lkIH1dXG4gICAgICBjb25zdCBwYXJzZU1lYXN1cmVtZW50SWQgPSAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgICAgaWYgKGFyZ3NbMF0gPT09ICdjb25maWcnICYmIGFyZ3NbMl0ub3JpZ2luID09PSAnZmlyZWJhc2UnKSB7XG4gICAgICAgICAgdGhpcy5tZWFzdXJlbWVudElkID0gYXJnc1sxXTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHBhdGNoR3RhZyA9IChmbj86ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCkgPT4ge1xuICAgICAgICB3aW5kb3dbR1RBR19GVU5DVElPTl9OQU1FXSA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEluamVjdCBhcHBfbmFtZSBhbmQgYXBwX3ZlcnNpb24gaW50byBldmVudHNcbiAgICAgICAgICAvLyBUT0RPKGphbWVzZGFuaWVscyk6IEknbSBkb2luZyB0aGlzIGFzIGRvY3VtZW50ZWQgYnV0IGl0J3Mgc3RpbGwgbm90XG4gICAgICAgICAgLy8gICBzaG93aW5nIHVwIGluIHRoZSBjb25zb2xlLiBJbnZlc3RpZ2F0ZS4gR3Vlc3NpbmcgaXQncyBqdXN0IHBhcnQgb2YgdGhlXG4gICAgICAgICAgLy8gICB3aG9sZSBHQTQgdHJhbnNpdGlvbiBtZXNzLlxuICAgICAgICAgIGlmIChhcmdzWzBdID09PSAnZXZlbnQnICYmIGFyZ3NbMl1bU0VORF9UT19LRVldID09PSB0aGlzLm1lYXN1cmVtZW50SWQpIHtcbiAgICAgICAgICAgIGlmIChwcm92aWRlZEFwcE5hbWUpIHtcbiAgICAgICAgICAgICAgYXJnc1syXVtBUFBfTkFNRV9LRVldID0gcHJvdmlkZWRBcHBOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3ZpZGVkQXBwVmVyc2lvbikge1xuICAgICAgICAgICAgICBhcmdzWzJdW0FQUF9WRVJTSU9OX0tFWV0gPSBwcm92aWRlZEFwcFZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWJ1Z01vZGVFbmFibGVkICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyguLi5hcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQWNjb3JkaW5nIHRvIHRoZSBndGFnIGRvY3VtZW50YXRpb24sIHRoaXMgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgY3VzdG9tIGRhdGEgbGF5ZXIgY2Fubm90IGJlXG4gICAgICAgICAgICogYW4gYXJyb3cgZnVuY3Rpb24gYmVjYXVzZSAnYXJndW1lbnRzJyBpcyBub3QgYW4gYXJyYXkuIEl0IGlzIGFjdHVhbGx5IGFuIG9iamVjdCB0aGF0IGJlaGF2ZXNcbiAgICAgICAgICAgKiBsaWtlIGFuIGFycmF5IGFuZCBjb250YWlucyBtb3JlIGluZm9ybWF0aW9uIHRoZW4ganVzdCBpbmRleGVzLiBUcmFuc2Zvcm1pbmcgdGhpcyBpbnRvIGFycm93IGZ1bmN0aW9uXG4gICAgICAgICAgICogY2F1c2VkIGlzc3VlICMyNTA1IHdoZXJlIGFuYWx5dGljcyBubyBsb25nZXIgc2VudCBhbnkgZGF0YS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG9ubHktYXJyb3ctZnVuY3Rpb25zXG4gICAgICAgICAgKGZ1bmN0aW9uKC4uLl9hcmdzOiBhbnlbXSkge1xuICAgICAgICAgICAgd2luZG93W0RBVEFfTEFZRVJfTkFNRV0ucHVzaChhcmd1bWVudHMpO1xuICAgICAgICAgIH0pKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgLy8gVW5jbGVhciBpZiB3ZSBzdGlsbCBuZWVkIHRvIGJ1dCBJIHdhcyBydW5uaW5nIGludG8gY29uZmlnL2V2ZW50cyBJIHBhc3NlZFxuICAgICAgLy8gdG8gZ3RhZyBiZWZvcmUgWydqcycgdGltZXN0YW1wXSB3ZXJlbid0IGdldHRpbmcgcGFyc2VkLCBzbyBsZXQncyBtYWtlIGEgcHJvbWlzZVxuICAgICAgLy8gdGhhdCByZXNvbHZlcyB3aGVuIGZpcmViYXNlL2FuYWx5dGljcyBoYXMgY29uZmlndXJlZCBndGFnLmpzIHRoYXQgd2Ugd2FpdCBvblxuICAgICAgLy8gYmVmb3JlIHNlbmRpbmcgYW55dGhpbmdcbiAgICAgIGNvbnN0IGZpcmViYXNlQW5hbHl0aWNzQWxyZWFkeUluaXRpYWxpemVkID0gd2luZG93W0RBVEFfTEFZRVJfTkFNRV0uc29tZShwYXJzZU1lYXN1cmVtZW50SWQpO1xuICAgICAgaWYgKGZpcmViYXNlQW5hbHl0aWNzQWxyZWFkeUluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuYW5hbHl0aWNzSW5pdGlhbGl6ZWQgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgcGF0Y2hHdGFnKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFuYWx5dGljc0luaXRpYWxpemVkID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgcGF0Y2hHdGFnKCguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyc2VNZWFzdXJlbWVudElkKC4uLmFyZ3MpKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm92aWRlZENvbmZpZykge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbmZpZyhwcm92aWRlZENvbmZpZyk7XG4gICAgICB9XG4gICAgICBpZiAoZGVidWdNb2RlRW5hYmxlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbmZpZyh7IFtERUJVR19NT0RFX0tFWV06IDEgfSk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLmFuYWx5dGljc0luaXRpYWxpemVkID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICB9XG5cbiAgICBjb25zdCBhbmFseXRpY3MgPSBvZih1bmRlZmluZWQpLnBpcGUoXG4gICAgICBvYnNlcnZlT24obmV3IMm1QW5ndWxhckZpcmVTY2hlZHVsZXJzKHpvbmUpLm91dHNpZGVBbmd1bGFyKSxcbiAgICAgIHN3aXRjaE1hcCgoKSA9PiBpbXBvcnQoJ2ZpcmViYXNlL2FuYWx5dGljcycpKSxcbiAgICAgIHN3aXRjaE1hcCgoKSA9PiBmaXJlYmFzZS5hbmFseXRpY3MuaXNTdXBwb3J0ZWQoKS50aGVuKGl0ID0+IGl0LCAoKSA9PiBmYWxzZSkpLFxuICAgICAgLy8gVE9ETyBzZXJ2ZXItc2lkZSBpbnZlc3RpZ2F0ZSB1c2Ugb2YgdGhlIFVuaXZlcnNhbCBBbmFseXRpY3MgQVBJXG4gICAgICBzd2l0Y2hNYXAoc3VwcG9ydGVkID0+IHN1cHBvcnRlZCA/IG9mKHVuZGVmaW5lZCkgOiBFTVBUWSksXG4gICAgICBtYXAoKCkgPT4ge1xuICAgICAgICByZXR1cm4gybVmZXRjaEluc3RhbmNlKGBhbmFseXRpY3NgLCAnQW5ndWxhckZpcmVBbmFseXRpY3MnLCBhcHAsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBhbmFseXRpY3MgPSBhcHAuYW5hbHl0aWNzKCk7XG4gICAgICAgICAgaWYgKGFuYWx5dGljc0NvbGxlY3Rpb25FbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYW5hbHl0aWNzLnNldEFuYWx5dGljc0NvbGxlY3Rpb25FbmFibGVkKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFuYWx5dGljcztcbiAgICAgICAgfSwgW2FwcCwgYW5hbHl0aWNzQ29sbGVjdGlvbkVuYWJsZWQsIHByb3ZpZGVkQ29uZmlnLCBkZWJ1Z01vZGVFbmFibGVkXSk7XG4gICAgICB9KSxcbiAgICAgIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IGZhbHNlIH0pXG4gICAgKTtcblxuICAgIHJldHVybiDJtWxhenlTREtQcm94eSh0aGlzLCBhbmFseXRpY3MsIHpvbmUpO1xuXG4gIH1cblxufVxuXG7JtWFwcGx5TWl4aW5zKEFuZ3VsYXJGaXJlQW5hbHl0aWNzLCBbcHJveHlQb2x5ZmlsbENvbXBhdF0pO1xuIl19